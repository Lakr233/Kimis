#!/bin/bash

PROJECT_ROOT="$(pwd)"
SWIFT_FILES_DIR="$PROJECT_ROOT/Kimis"
ANCHOR_FILE="$PROJECT_ROOT/Kimis/Resources/L10nAnchors.swift"
XCSTRINGS_FILE="$PROJECT_ROOT/Kimis/Resources/Localizable.xcstrings"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}ℹ️ $1${NC}" >&2
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}" >&2
}

log_warning() {
    echo -e "${YELLOW}⚠️ $1${NC}" >&2
}

log_error() {
    echo -e "${RED}❌ $1${NC}" >&2
}

extract_localization_keys() {
    log_info "扫描 Swift 文件中的本地化键..."

    # 临时文件存储提取的键
    local temp_file=$(mktemp)

    # 查找所有 Swift 文件（排除锚点文件本身）
    find "$SWIFT_FILES_DIR" -name "*.swift" ! -name "L10nAnchors.swift" -type f | while read -r swift_file; do
        # 提取 L10n.text 调用中的字符串
        grep -o 'L10n\.text(\s*"[^"]*"' "$swift_file" 2>/dev/null |
            sed 's/L10n\.text(\s*"\([^"]*\)"/\1/' |
            sed 's/\\n/\n/g' |
            sed 's/\\"/"/g' |
            grep -v '^L10n\.text' >>"$temp_file"

        # 提取带参数的 L10n.text 调用
        grep -o 'L10n\.text(\s*"[^"]*"\s*,' "$swift_file" 2>/dev/null |
            sed 's/L10n\.text(\s*"\([^"]*\)"\s*,/\1/' |
            sed 's/\\n/\n/g' |
            sed 's/\\"/"/g' |
            grep -v '^L10n\.text' >>"$temp_file"
    done

    # 过滤掉日志信息等非本地化字符串
    grep -v '^\[0;' "$temp_file" | grep -v '^ℹ️' >"${temp_file}.filtered"
    mv "${temp_file}.filtered" "$temp_file"

    # 去重并排序
    sort -u "$temp_file"

    # 清理临时文件
    rm -f "$temp_file"
}

read_existing_xcstrings_keys() {
    if [[ -f "$XCSTRINGS_FILE" ]]; then
        # 使用 jq 提取 .xcstrings 文件中的所有键
        if command -v jq >/dev/null 2>&1; then
            jq -r '.strings | keys[]' "$XCSTRINGS_FILE" 2>/dev/null | sort
        else
            log_warning "未找到 jq 命令，无法读取 .xcstrings 文件"
            echo ""
        fi
    else
        echo ""
    fi
}
generate_anchor_file() {
    local keys_file="$1"

    log_info "生成锚点文件..."

    # 生成文件头
    cat >"$ANCHOR_FILE" <<'EOF'
//
//  L10nAnchors.swift
//  Kimis
//
//  Created by Star on 2025/10/8.
//  DO NOT EDIT MANUALLY - This file is automatically generated
//

import Foundation

// DO NOT call these at runtime. They are only for Xcode string extraction.
enum _L10nAnchors {
    static func _register() {
EOF

    # 添加所有键
    while IFS= read -r key; do
        if [[ -n "$key" ]]; then
            # 转义特殊字符
            escaped_key=$(echo "$key" | sed 's/"/\\"/g' | sed 's/\n/\\n/g')
            echo "        _ = NSLocalizedString(\"$escaped_key\", comment: \"\")" >>"$ANCHOR_FILE"
        fi
    done <"$keys_file"

    # 生成文件尾
    cat >>"$ANCHOR_FILE" <<'EOF'
    }
}
EOF
}

main() {
    log_info "开始更新本地化键..."

    # 提取代码中的键
    local code_keys_file=$(mktemp)
    extract_localization_keys >"$code_keys_file"
    local code_keys_count=$(wc -l <"$code_keys_file" | tr -d ' ')

    # 读取现有的 .xcstrings 文件中的键
    local existing_keys_file=$(mktemp)
    read_existing_xcstrings_keys >"$existing_keys_file"
    local existing_keys_count=$(wc -l <"$existing_keys_file" | tr -d ' ')

    log_success "在代码中找到 $code_keys_count 个本地化键"
    log_success "在 .xcstrings 文件中找到 $existing_keys_count 个现有键"

    # 生成锚点文件
    generate_anchor_file "$code_keys_file"

    # 计算新添加的键
    local new_keys_file=$(mktemp)
    comm -23 "$code_keys_file" "$existing_keys_file" >"$new_keys_file"
    local new_keys_count=$(wc -l <"$new_keys_file" | tr -d ' ')

    log_success "已更新 $ANCHOR_FILE"
    echo ""
    echo "📊 统计:"
    echo "   - 代码中的键: $code_keys_count"
    echo "   - 现有 .xcstrings 键: $existing_keys_count"
    echo "   - 新添加的键: $new_keys_count"

    # 显示新添加的键
    if [[ $new_keys_count -gt 0 ]]; then
        echo ""
        echo "🆕 新发现的键:"
        while IFS= read -r key; do
            echo "   - $key"
        done <"$new_keys_file"
    fi

    # 清理临时文件
    rm -f "$code_keys_file" "$existing_keys_file" "$new_keys_file"
}

# 检查是否在项目根目录运行
if [[ ! -d "$SWIFT_FILES_DIR" ]]; then
    log_error "请在项目根目录运行此脚本"
    exit 1
fi

# 运行主函数
main
